// Zaimoni.STL/augment.STL/cmath

#ifndef ZAIMONI_AUGMENT_STL_TYPE_CMATH
#define ZAIMONI_AUGMENT_STL_TYPE_CMATH 1

#include <cmath>
#include "type_traits"

// namespace setup.  Anything we would want for high-precision arithmetic should be imported into both of our namespaces.
// Favor once-and-only-once over technical efficiency.

namespace zaimoni {

	using std::fpclassify;

namespace math {

	using std::fpclassify;

}	// namespace math

}	// namespace zaimoni

// intentionally close and re-open namespaces to visually separate intent (reference vs. new definitions)

namespace zaimoni {

// XXX extending cmath functions to integers with templates does not work (templates are lower priority than functions
// when resolving overloads)
template<class T>
constexpr typename std::enable_if<std::is_floating_point<T>::value, bool>::type isINF(T x)
{
	return std::isinf(x);
}

template<class T>
constexpr typename std::enable_if<std::is_floating_point<T>::value, bool>::type isFinite(T x)
{
	return std::isfinite(x);
}

template<class T>
constexpr typename std::enable_if<std::is_floating_point<T>::value, bool>::type isNaN(T x)
{
	return std::isnan(x);
}

template<class T>
constexpr typename std::enable_if<std::is_floating_point<T>::value, bool>::type signBit(T x)
{
	return std::signbit(x);
}

template<class T>
constexpr typename std::enable_if<std::is_floating_point<T>::value, typename std::remove_const<T>::type>::type scalBn(T x, int scale)
{
	return std::scalbn(x, scale);
}

namespace math {

namespace bits
{
	template<class T>
	constexpr typename std::enable_if<std::is_floating_point<T>::value, bool>::type sum_overflows(T lhs, T rhs)
	{
		if (0 == lhs) return false;
		if (0 == rhs) return false;
		if ((0 < lhs) != (0 < rhs)) return false;	// NaN is not overflow
		if (std::isinf(lhs)) return false;
		if (std::isinf(rhs)) return false;

		int exponent[2] = { 0,0 };
		long double mantissa[2] = { frexp(lhs, exponent + 0) , frexp(rhs, exponent + 1) };
		if (std::numeric_limits<long double>::max_exponent - 2 <  exponent[0] && std::numeric_limits<long double>::max_exponent - 2 <  exponent[1]) return true;
		if (std::numeric_limits<long double>::max_exponent - 2 >= exponent[0] && std::numeric_limits<long double>::max_exponent - 2 >= exponent[1]) return false;
		// corner case
		const int gt_index = (exponent[0] < exponent[1]);
		const int lt_index = 1 - gt_index;
		return 2 - mantissa[gt_index] <= scalbn(mantissa[lt_index], exponent[lt_index] - exponent[gt_index]);	// XXX \todo verify this
	}
}

template<>
struct would_overflow<long double>
{
	static constexpr bool sum(long double lhs, long double rhs) { return bits::sum_overflows(lhs, rhs); }
};

template<>
struct would_overflow<double>
{
	static constexpr bool sum(double lhs, double rhs) { return bits::sum_overflows(lhs, rhs); }
};

template<>
struct would_overflow<float>
{
	static constexpr bool sum(float lhs, float rhs) { return bits::sum_overflows(lhs, rhs); }
};

}	// namespace math
}	// namespace zaimoni

#endif
