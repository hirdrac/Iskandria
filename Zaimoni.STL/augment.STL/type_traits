// Zaimoni.STL/Augment.STL/typetraits

#ifndef ZAIMONI_AUGMENT_STL_TYPETRAITS
#define ZAIMONI_AUGMENT_STL_TYPETRAITS 1

#include <type_traits>

namespace zaimoni {

// replicate efficient function declaration types from Boost
template<class T> struct const_param
{
	typedef typename std::conditional<sizeof(unsigned long long)>=sizeof(T) , const T , typename std::add_lvalue_reference<const T>::type >::type type;
};

template<class T> struct return_copy
{
	typedef typename std::conditional<sizeof(unsigned long long)>=sizeof(T) , T , 
		typename std::add_lvalue_reference<const T>::type 
	>::type type;
};

// extend some cmath functions to integers
// This *will* hard-error if math.h is used rather than cmath on TDM GCC 5.1 (defines)
template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value, bool>::type isinf(T x)
{
	return true;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value, bool>::type isfinite(T x)
{
	return true;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value, bool>::type isnan(T x)
{
	return false;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value && std::is_signed<T>::value, bool>::type signbit(T x)
{
	return 0>x;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value && std::is_unsigned<T>::value, bool>::type signbit(T x)
{
	return false;
}

namespace math {

template<class T>
struct static_cache
{
	template<intmax_t n> 
	static typename std::enable_if<
			std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value,
		typename return_copy<T>::type>::type as()
	{
		static const T ret(n);
		return ret;
	}
};

template<intmax_t n, class T>
typename std::enable_if<
			std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value,
		typename return_copy<typename std::remove_reference<T>::type>::type>::type int_as()
{
	return static_cache<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::template as<n>();
}

template<intmax_t n, class T>
constexpr typename std::enable_if<std::is_arithmetic<typename std::remove_reference<T>::type>::value , typename std::remove_reference<T>::type >::type int_as()
{
	return n;
}
#define ZAIMONI_INT_AS_DEFINED(T) (std::is_arithmetic<typename std::remove_reference<T>::type>::value || (std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value))

// numerical error calculation -- baseline
template<class T>
struct numerical
{
	enum {
		error_tracking = 0
	};
	typedef typename std::remove_cv<T>::type exact_type;			// exact version of this type
	typedef typename std::remove_cv<T>::type exact_arithmetic_type;	// exact version of the individual coordinates of this type

	static constexpr int error(typename const_param<T>::type src) {return 0;}
	static constexpr bool causes_division_by_zero(typename const_param<T>::type src) {return int_as<0,T>()==src;};
};

template<class T>
constexpr bool causes_division_by_zero(T src)
{
	return numerical<typename std::remove_reference<typename std::remove_cv<T>::type>::type>::causes_division_by_zero(src);
}

}	// namespace math
}	// namespace zaimoni

#endif
