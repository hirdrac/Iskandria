// Zaimoni.STL/Augment.STL/typetraits

#ifndef ZAIMONI_AUGMENT_STL_TYPETRAITS
#define ZAIMONI_AUGMENT_STL_TYPETRAITS 1

#include <limits>
#include <type_traits>

namespace zaimoni {

// replicate efficient function declaration types from Boost
template<class T> struct const_param
{
	typedef typename std::conditional<sizeof(unsigned long long)>=sizeof(T) , const T , typename std::add_lvalue_reference<const T>::type >::type type;
};

template<class T> struct return_copy
{
	typedef typename std::conditional<sizeof(unsigned long long)>=sizeof(T) , T , 
		typename std::add_lvalue_reference<const T>::type 
	>::type type;
};

// we don't have good compile-time detection for operators, and STL conflicts with mathematics at times anyway
template<class T> struct op_works
{
	enum {
		add = std::is_arithmetic<T>::value,
		sub = std::is_arithmetic<T>::value,
		mult = std::is_arithmetic<T>::value,
		div = std::is_arithmetic<T>::value,
		negate = std::is_arithmetic<T>::value,
		less_than = std::is_arithmetic<T>::value
	};
};

// abs is taken by the standard library.
// norm is meant to be the "typical" measure of absolute value; for real numbers should be abs
template<class T>
constexpr  typename std::enable_if<
   std::is_floating_point<T>::value,
T>::type norm(T x) {return 0<=x ? x : -x;}

template<class T>
constexpr  typename std::enable_if<
   std::is_integral<T>::value
&& std::is_unsigned<T>::value,
T>::type norm(T x) {return x;}

template<class T>
constexpr  typename std::enable_if<
   std::is_integral<T>::value
&& std::is_signed<T>::value
&& std::numeric_limits<T>::min() >= -std::numeric_limits<T>::max(),
typename std::make_unsigned<T>::type>::type norm(T x) {return 0<=x ? x : -x;}

// XXX operator > will close the template prematurely
template<class T>
constexpr  typename std::enable_if<
   std::is_integral<T>::value
&& std::is_signed<T>::value
&& std::numeric_limits<T>::min() < -std::numeric_limits<T>::max(),
typename std::make_unsigned<T>::type>::type norm(T x)
{	// XXX 2's complement integer minimum is undefined behavior to negate
	return 0<=x ? x
	  : (-std::numeric_limits<T>::max()<=x) ? -x
			  : (typename std::make_unsigned<T>::type)(std::numeric_limits<T>::max())+(typename std::make_unsigned<T>::type)(-std::numeric_limits<T>::max()-x);
}

// correct-size type estimation
template<uintmax_t n>
struct min_unsigned
{
	typedef typename std::conditional<std::numeric_limits<unsigned int>::max()<=n,
			typename std::conditional<std::numeric_limits<unsigned char>::max()<=n,
				unsigned char,
				typename std::conditional<std::numeric_limits<unsigned short>::max(),
					unsigned short,
					unsigned int>::type
			>::type,
			typename std::conditional<std::numeric_limits<unsigned long>::max()<=n,	unsigned long, uintmax_t>::type>::type type;
};

// extend some cmath functions to integers
// This *will* hard-error if math.h is used rather than cmath on TDM GCC 5.1 (defines)
template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value, bool>::type isinf(T x)
{
	return true;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value, bool>::type isfinite(T x)
{
	return true;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value, bool>::type isnan(T x)
{
	return false;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value && std::is_signed<T>::value, bool>::type signbit(T x)
{
	return 0>x;
}

template<class T>
constexpr typename std::enable_if<std::is_integral<T>::value && std::is_unsigned<T>::value, bool>::type signbit(T x)
{
	return false;
}

namespace math {

template<class T>
struct static_cache
{
	template<intmax_t n> 
	static typename std::enable_if<
			std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value,
		typename return_copy<T>::type>::type as()
	{
		static const T ret(n);
		return ret;
	}

	template<uintmax_t n> 
	static typename std::enable_if<
			std::is_convertible<uintmax_t, T>::value && !std::is_scalar<T>::value && std::numeric_limits<intmax_t>::max()<n,
		typename return_copy<T>::type>::type as2()
	{
		static const T ret(n);
		return ret;
	}
};

template<intmax_t n, class T>
typename std::enable_if<
			std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value,
		typename return_copy<typename std::remove_reference<T>::type>::type>::type int_as()
{
	return static_cache<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::template as<n>();
}

template<intmax_t n, class T>
constexpr typename std::enable_if<std::is_arithmetic<typename std::remove_reference<T>::type>::value , typename std::remove_reference<T>::type >::type int_as()
{
       return n;
}

template<uintmax_t n, class T>
typename std::enable_if<
			std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value && std::numeric_limits<intmax_t>::max()>=n,
		typename return_copy<typename std::remove_reference<T>::type>::type>::type unint_as()
{
	return static_cache<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::template as<n>();
}

template<uintmax_t n, class T>
typename std::enable_if<
			std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value && std::numeric_limits<intmax_t>::max()<n,
		typename return_copy<typename std::remove_reference<T>::type>::type>::type unint_as()
{
	return static_cache<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::template as2<n>();
}

template<uintmax_t n, class T>
constexpr typename std::enable_if<std::is_arithmetic<typename std::remove_reference<T>::type>::value , typename std::remove_reference<T>::type >::type uint_as()
{
       return n;
}
#define ZAIMONI_INT_AS_DEFINED(T) (std::is_arithmetic<typename std::remove_reference<T>::type>::value || (std::is_convertible<intmax_t, T>::value && !std::is_scalar<T>::value))

template<uintmax_t n>
struct unsigned_fn
{
	constexpr static uintmax_t constant() { return n; }
	template<class T> static bool kronecker_delta(typename const_param<T>::type rhs) { return uint_as<n,T>()==rhs; }
};

template<intmax_t n>
struct signed_fn
{
	constexpr static intmax_t constant() { return n; }
	template<class T> static bool kronecker_delta(typename const_param<T>::type rhs) { return int_as<n,T>()==rhs; }
};


// numerical error calculation -- baseline
template<class T>
struct numerical
{
	enum {
		error_tracking = 0
	};
	typedef typename std::remove_cv<T>::type exact_type;			// exact version of this type
	typedef typename std::remove_cv<T>::type exact_arithmetic_type;	// exact version of the individual coordinates of this type

	static constexpr int error(typename const_param<T>::type src) {return 0;}
	static constexpr bool causes_division_by_zero(typename const_param<T>::type src) {return int_as<0,T>()==src;};
};

template<class T>
constexpr bool causes_division_by_zero(T src)
{
	return numerical<typename std::remove_reference<typename std::remove_cv<T>::type>::type>::causes_division_by_zero(src);
}

}	// namespace math

}	// namespace zaimoni

#endif
